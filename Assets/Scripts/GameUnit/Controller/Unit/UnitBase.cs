using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UnitBase : Unit
{
    [SerializeField] protected UnitClass unitClass;
    protected UnitStat unitStat;
    protected List<Unit> monCtrls = new List<Unit>();  //범위안에 들어온 몬스터의 정보들을 모아둠
    [SerializeField] protected Unit monTarget;  //몬스터들의 정보들중에서 제일 유닛과 가까운 몬스터정보를 받아옴
    [SerializeField] protected MonsterPortal monsterPortal;
    protected Dictionary<UnitClass, UnitStat> unitStatDict;


    protected readonly string appearTitleKey = "unitAppearDialog";
    protected readonly string dieTitleKey = "unitDieDialog";
    protected readonly string dieDialogSubKey = "specialUnitDie";


    public Unit Monctrl { get { return monTarget; } }
    public MonsterPortal MonsterPortal { get { return monsterPortal; } }
    // Start is called before the first frame update


    public override void OnEnable()
    {

    }


    public override void Init()
    {
        base.Init();
        unitStatDict = new Dictionary<UnitClass, UnitStat>
        {
            { UnitClass.Warrior , Managers.Data.warriorDict[Managers.Game.UnitWarriorLv] },
            { UnitClass.Archer , Managers.Data.archerDict[Managers.Game.UnitArcherLv] },
            { UnitClass.Spear , Managers.Data.spearDict[Managers.Game.UnitSpearLv] },
            { UnitClass.Priest , Managers.Data.spearDict[Managers.Game.UnitPriestLv] },
            { UnitClass.Magician , Managers.Data.magicDict[Managers.Game.UnitMagicianLv] },
            { UnitClass.Cavalry , Managers.Data.cavarlyDict[Managers.Game.UnitCavalryLv] },

        };


        unitStat = new UnitStat();
        unitStat = unitStatDict[unitClass];

        hp = unitStat.hp;
        att = unitStat.att;
        knockbackForce = unitStat.knockBackForce;
        attackRange = unitStat.attackRange;

        moveSpeed = 2.5f;
        maxHp = hp;


    }

    protected virtual void UnitSense()
    {
        //타겟리스트 초기화해줌
        monCtrls.Clear();
        enemyColls2D = Physics2D.OverlapBoxAll(pos.position, boxSize, 0, LayerMask.GetMask("Monster") | LayerMask.GetMask("EliteMonster"));
        if (enemyColls2D != null)
        {
            if (enemyColls2D.Length <= 0)
            {

                TowerSensor();
                //박스안 콜라이더가 아무것도 없으면
                if (monTarget != null)  //이전에 몬스터 타겟팅이 잡혓더라면
                {
                    monTarget = null;
                    return;
                }
            }
            else
            {
                monsterPortal = null;
            }


            //체크박스안에 들어온 콜라이더중에서 현재 유닛과의 거리가 제일 가까운 것을 골라내기
            for (int ii = 0; ii < enemyColls2D.Length; ii++)
            {
                if (enemyColls2D[ii].gameObject.layer == LayerMask.NameToLayer("Monster"))
                {
                    MonsterController monctrl;
                    enemyColls2D[ii].TryGetComponent<MonsterController>(out monctrl);
                    monCtrls.Add(monctrl);

                }
                else if (enemyColls2D[ii].gameObject.layer == LayerMask.NameToLayer("EliteMonster"))
                {
                    EliteMonsterController elite;
                    enemyColls2D[ii].TryGetComponent<EliteMonsterController>(out elite);
                    monCtrls.Add(elite);

                }
            }


        }
    }

    //감지한 유닛들의 해당 캐릭터와의 거리 오름차순
    protected virtual void UnitDistanceAsending()
    {
        if (monCtrls.Count > 0)
        {
            float disMin = 0;
            int min = 0;


            if (monCtrls.Count > 1)
            {
                for (int i = 0; i < monCtrls.Count; i++)
                {
                    if (i == 0 && monCtrls.Count > 1)
                    {

                        float distA = (monCtrls[i].transform.position - this.transform.position).sqrMagnitude;
                        float distB = (monCtrls[i + 1].transform.position - this.transform.position).sqrMagnitude;

                        if (distA * distA > distB * distB)
                        {
                            disMin = distB * distB;
                            min = i + 1;
                        }
                        else
                        {
                            disMin = distA * distA;
                            min = i;
                        }
                    }

                    else if (i < monCtrls.Count - 1)
                    {
                        float distB = (monCtrls[i + 1].transform.position - this.transform.position).sqrMagnitude;

                        if (disMin > distB * distB)
                        {
                            disMin = distB * distB;
                            min = i + 1;
                        }


                    }

                }
            }


            if (monCtrls.Count != 0)
            {
                monTarget = monCtrls[min];
            }

        }
    }


    void TowerSensor()
    {
        towerColl = Physics2D.OverlapBox(pos.position, boxSize, 0, LayerMask.GetMask("MonsterPortal"));
        if (towerColl != null)
            towerColl.TryGetComponent(out monsterPortal);
    }

    void UnitIdle()
    {
        AttackDelay();

    }

    protected virtual bool IsTargetOn()
    {
        if (monTarget == null && monsterPortal == null)
            return false;


        if (monTarget != null)
        {
            if (monTarget.gameObject.layer == LayerMask.NameToLayer("Monster") && monTarget is MonsterController monsterCtrl)
            {
                if (monsterCtrl.MonState == MonsterState.Die)
                    return false;

                if (!monTarget.gameObject.activeInHierarchy)
                    return false;
            }

            else if (monTarget.gameObject.layer == LayerMask.NameToLayer("EliteMonster") && monTarget is EliteMonsterController elite)
            {
                if (elite.MonState == Define.EliteMonsterState.Die)
                    return false;

                if (!monTarget.gameObject.activeInHierarchy)
                    return false;
            }

        }



        return true;
    }


    public override void OnHeal(int heal)
    {
        if (hp > 0)
        {
            unitHUDHp?.SpawnHUDText(heal.ToString(), (int)Define.UnitDamageType.Team);
            hp += heal;
            NotifyToHpObserver();       //체력이 바뀌어서 옵저버들에게 체력이 바꼇다는걸 알리고 보내기

        }

        if (hp >= maxHp)
            hp = maxHp;
    }

    public override void OnAttack()    //애니메이션 이벤트 함수
    {


    }


    public override bool CriticalCheck()
    {
        //유닛공격력을 받아서 크리티컬확률을 받아서 확률에 맞으면 크리공격
        //아니면 일반 공격
        int rand = UnityEngine.Random.Range(0, 101);
        if (rand <= unitStat.criticalRate)
            return true;

        return false;


    }

    public override void CriticalAttack(Unit monCtrl, string soundPath, string criticalSoundPath, string hitPath)
    {
        if (CriticalCheck())//true면 크리티컬데미지 false면 일반데미지
        {
            int attack = att * 2;
            monCtrl.OnDamage(attack, unitStat.knockBackForce, true);      //크리티컬이면 데미지2배에 넉백까지
            Managers.Resource.ResourceEffectAndSound(monTarget.transform.position, criticalSoundPath, hitPath);

        }
        else  //노크리티컬이면 일반공격
        {

            monCtrl.OnDamage(att);        //넉백은 없이
            Managers.Resource.ResourceEffectAndSound(monTarget.transform.position, soundPath, hitPath);

        }
    }

    public override void CriticalAttack(Tower monPortal, string soundPath, string criticalSoundPath, string hitPath)
    {
        if (CriticalCheck())//true면 크리티컬데미지 false면 일반데미지
        {
            int attack = att * 2;
            monPortal.TowerDamage(attack);      //크리티컬이면 데미지2배 타워는 2배만
            Managers.Resource.ResourceEffectAndSound(monPortal.transform.position, criticalSoundPath, hitPath);

        }
        else  //노크리티컬이면 일반공격
        {
            monPortal.TowerDamage(att);        //넉백은 없이
            Managers.Resource.ResourceEffectAndSound(monPortal.transform.position, soundPath, hitPath);

        }
    }


    public void SpeechBubbleOn(string speechTitleKey, string speechSubKey, int probaility)
    {
        speechBubble.SpeechBubbleOn(speechTitleKey, speechSubKey, probaility);


    }

    public override void EnemySensor()
    {
    }

    public override void AttackDelay()
    {

    }

    public override void OnDamage(int att, int knockBack = 0, bool criticalCheck = false)
    {

    }
}
